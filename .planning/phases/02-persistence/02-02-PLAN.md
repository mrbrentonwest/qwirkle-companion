---
phase: 02-persistence
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/firestore-game.ts
  - src/hooks/use-game-persistence.ts
autonomous: true

must_haves:
  truths:
    - "Game state can be saved to Firestore"
    - "Game state can be loaded from Firestore"
    - "Game state can be deleted from Firestore"
    - "Real-time listener receives updates from Firestore"
  artifacts:
    - path: "src/lib/firestore-game.ts"
      provides: "CRUD operations for game documents"
      exports: ["saveActiveGame", "loadActiveGame", "clearActiveGame"]
    - path: "src/hooks/use-game-persistence.ts"
      provides: "Hook for game state synchronization"
      exports: ["useGamePersistence"]
  key_links:
    - from: "src/lib/firestore-game.ts"
      to: "src/lib/firebase.ts"
      via: "import { db } from firebase"
      pattern: "import.*db.*from.*firebase"
    - from: "src/hooks/use-game-persistence.ts"
      to: "src/lib/firestore-game.ts"
      via: "import CRUD functions"
      pattern: "import.*from.*firestore-game"
    - from: "src/hooks/use-game-persistence.ts"
      to: "firebase/firestore"
      via: "onSnapshot listener"
      pattern: "onSnapshot"
---

<objective>
Create Firestore game operations and a React hook for automatic game persistence.

Purpose: Provide the data layer for saving/loading games and a hook that handles the complexity of real-time sync with debounced writes.

Output: `firestore-game.ts` with CRUD functions, `use-game-persistence.ts` hook with auto-save and real-time loading.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence/02-RESEARCH.md
@.planning/phases/02-persistence/02-01-SUMMARY.md
@src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Firestore game CRUD operations</name>
  <files>src/lib/firestore-game.ts</files>
  <action>
Create `src/lib/firestore-game.ts` with game document operations:

1. Import `db` from '@/lib/firebase'
2. Import `doc`, `setDoc`, `getDoc`, `deleteDoc` from 'firebase/firestore'
3. Import `GameState` from '@/lib/types'

Document path: `users/{userId}/activeGame/current`
(Single active game per user, as specified in research)

Functions to create:

```typescript
// Save game (upsert pattern with merge)
async function saveActiveGame(userId: string, gameState: GameState): Promise<void>
- Use setDoc with { merge: true }
- Add updatedAt timestamp (ISO string)
- Add createdAt if it doesn't exist (use serverTimestamp or ISO string)

// Load game (one-time read)
async function loadActiveGame(userId: string): Promise<GameState | null>
- Use getDoc
- Return null if document doesn't exist
- Cast data() to GameState

// Delete game (clear active game)
async function clearActiveGame(userId: string): Promise<void>
- Use deleteDoc
```

TypeScript: Create a `StoredGameState` interface that extends `GameState` with:
- createdAt: string
- updatedAt: string

Export all three functions.

DO NOT:
- Use updateDoc (setDoc with merge handles creates and updates)
- Forget { merge: true } (would overwrite entire document)
- Store the full undo/redo history (only current state)
  </action>
  <verify>
1. File exists: `ls src/lib/firestore-game.ts`
2. TypeScript compiles: `npx tsc --noEmit` or check IDE
3. Exports correct: File exports saveActiveGame, loadActiveGame, clearActiveGame
  </verify>
  <done>
Firestore CRUD module exists with three exported functions for save, load, and clear operations using proper document paths and merge semantics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useGamePersistence hook</name>
  <files>src/hooks/use-game-persistence.ts</files>
  <action>
Create `src/hooks/use-game-persistence.ts` with game sync logic:

```typescript
interface UseGamePersistenceOptions {
  userId: string | null;
  isFirebaseReady: boolean;
}

interface UseGamePersistenceReturn {
  // Initial game loaded from Firestore (null if none exists)
  initialGame: GameState | null;
  // Loading state
  isLoading: boolean;
  // Save function (debounced internally)
  saveGame: (gameState: GameState) => void;
  // Clear function (for game reset)
  clearGame: () => Promise<void>;
  // Error state
  error: Error | null;
}

function useGamePersistence(options: UseGamePersistenceOptions): UseGamePersistenceReturn
```

Implementation details:

1. **Loading (useEffect):**
   - When userId and isFirebaseReady are both truthy, set up onSnapshot listener
   - On first snapshot, set initialGame state
   - Track loading state (true until first snapshot received)
   - Clean up listener on unmount or userId change

2. **Saving (debounced):**
   - Use useRef for timeout to persist across renders
   - saveGame function clears existing timeout, sets new 500ms timeout
   - After timeout, calls saveActiveGame from firestore-game.ts
   - Don't save if userId is null

3. **Clearing:**
   - Calls clearActiveGame from firestore-game.ts
   - Resets local state

4. **Error handling:**
   - Catch errors in listener and save operations
   - Store in error state for consumer to display if needed
   - Log errors to console

Key patterns from research:
- onSnapshot with cleanup (return unsubscribe from useEffect)
- 500ms debounce for saves (prevents rate limit issues)
- Loading state until first snapshot

DO NOT:
- Call onSnapshot outside useEffect (memory leak)
- Forget to return unsubscribe function from useEffect
- Save immediately without debounce (rate limits)
- Block on save completion (fire and forget with error handling)
  </action>
  <verify>
1. File exists: `ls src/hooks/use-game-persistence.ts`
2. TypeScript compiles without errors
3. Hook exports useGamePersistence
4. Uses useEffect with cleanup for listener
5. Has debounce logic (setTimeout/clearTimeout pattern)
  </verify>
  <done>
useGamePersistence hook exists with onSnapshot listener for loading, debounced save function, clear function, and proper cleanup on unmount.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. TypeScript compiles: `npm run build` or `npx tsc --noEmit`
2. No circular import issues
3. Hook can be imported: `import { useGamePersistence } from '@/hooks/use-game-persistence'`
4. Functions can be imported: `import { saveActiveGame } from '@/lib/firestore-game'`
</verification>

<success_criteria>
1. firestore-game.ts exports three CRUD functions
2. use-game-persistence.ts exports hook with loading, saving, and clearing
3. Debounce prevents rapid consecutive writes
4. onSnapshot listener is cleaned up properly
5. All TypeScript types are correct
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence/02-02-SUMMARY.md`
</output>
