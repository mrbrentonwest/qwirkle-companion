---
phase: 02-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/firebase.ts
  - src/contexts/identity-context.tsx
  - .env.local.example
autonomous: true
user_setup:
  - service: firebase
    why: "Cloud game state persistence"
    env_vars:
      - name: NEXT_PUBLIC_FIREBASE_API_KEY
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
      - name: NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
      - name: NEXT_PUBLIC_FIREBASE_PROJECT_ID
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
      - name: NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
      - name: NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
      - name: NEXT_PUBLIC_FIREBASE_APP_ID
        source: "Firebase Console -> Project Settings -> General -> Your apps -> Web app -> Config"
    dashboard_config:
      - task: "Enable Anonymous Authentication"
        location: "Firebase Console -> Authentication -> Sign-in method -> Anonymous -> Enable"
      - task: "Create Firestore database"
        location: "Firebase Console -> Firestore Database -> Create database -> Start in test mode (we'll add rules later)"

must_haves:
  truths:
    - "Firebase app initializes without errors on page load"
    - "Anonymous auth signs in automatically when app loads"
    - "Auth state persists across page refreshes"
  artifacts:
    - path: "src/lib/firebase.ts"
      provides: "Firebase singleton with db and auth exports"
      exports: ["db", "auth"]
    - path: "src/contexts/identity-context.tsx"
      provides: "Anonymous auth integration"
      contains: "signInAnonymously"
    - path: ".env.local.example"
      provides: "Template for required Firebase env vars"
      contains: "NEXT_PUBLIC_FIREBASE_API_KEY"
  key_links:
    - from: "src/contexts/identity-context.tsx"
      to: "src/lib/firebase.ts"
      via: "import { auth } from firebase"
      pattern: "import.*auth.*from.*firebase"
    - from: "src/lib/firebase.ts"
      to: "process.env.NEXT_PUBLIC_FIREBASE_*"
      via: "environment variables"
      pattern: "process\\.env\\.NEXT_PUBLIC_FIREBASE"
---

<objective>
Initialize Firebase and integrate Anonymous Authentication into the identity system.

Purpose: Establish the foundation for Firestore persistence by configuring Firebase with proper authentication that works alongside our existing passphrase-based identity.

Output: Firebase singleton module exporting `db` and `auth`, updated IdentityContext that signs in anonymously on load, and env var template.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence/02-RESEARCH.md
@.planning/phases/01-identity/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Firebase initialization singleton</name>
  <files>src/lib/firebase.ts, .env.local.example</files>
  <action>
Create `src/lib/firebase.ts` with Firebase singleton initialization:

1. Use 'use client' directive (Firebase only works client-side)
2. Import from 'firebase/app', 'firebase/firestore', 'firebase/auth'
3. Create firebaseConfig object reading from process.env.NEXT_PUBLIC_FIREBASE_* variables:
   - apiKey, authDomain, projectId, storageBucket, messagingSenderId, appId
4. Use getApps().length check to prevent duplicate initialization in dev hot reload
5. Guard initialization with `typeof window !== 'undefined'` for SSR safety
6. Export `db` (Firestore instance) and `auth` (Auth instance)

Also create `.env.local.example` with all required Firebase env vars (empty values) for documentation.

Pattern from research:
```typescript
const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];
```

DO NOT:
- Initialize Firebase at import time without window check (breaks SSR)
- Export app directly (only db and auth needed)
- Use namespace API (use modular imports)
  </action>
  <verify>
1. File exists: `ls src/lib/firebase.ts`
2. TypeScript compiles: `npx tsc --noEmit src/lib/firebase.ts` (or check via IDE)
3. Exports are correct: File exports `db` and `auth`
  </verify>
  <done>
Firebase singleton module exists with db and auth exports, guarded for SSR safety, using getApps() pattern for hot reload safety.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Anonymous Auth into IdentityContext</name>
  <files>src/contexts/identity-context.tsx</files>
  <action>
Modify `src/contexts/identity-context.tsx` to sign in anonymously with Firebase when identity is established:

1. Import `auth` from '@/lib/firebase'
2. Import `signInAnonymously`, `onAuthStateChanged` from 'firebase/auth'
3. Add `firebaseUid: string | null` to context value (for debugging, not used for data paths)
4. Add `isFirebaseReady: boolean` to context value
5. In IdentityProvider, add useEffect that:
   - Watches for when `isHydrated` becomes true AND `identity?.userId` exists
   - Calls `signInAnonymously(auth)` to authenticate
   - Uses `onAuthStateChanged` to track Firebase auth state
   - Sets `isFirebaseReady` to true once auth completes
   - Cleans up listener on unmount

Key insight: We sign in anonymously to satisfy Firestore security rules, but still use our custom `userId` (passphrase hash) for document paths. Firebase Anonymous Auth UID is NOT used for data organization.

DO NOT:
- Replace our userId with Firebase UID (our userId is the passphrase hash)
- Sign in before identity is established (only after passphrase entered)
- Block the UI on Firebase auth (identity UI should work independently)

Error handling: Log errors but don't crash - Firebase being unavailable shouldn't break the app.
  </action>
  <verify>
1. TypeScript compiles without errors
2. Context still exports all previous values (userId, passphrase, isLoading, isIdentified, setPassphrase, clearIdentity)
3. New exports exist: firebaseUid, isFirebaseReady
  </verify>
  <done>
IdentityContext signs in anonymously when passphrase is set, exposes firebaseUid and isFirebaseReady state, cleans up auth listener on unmount.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run dev` starts without errors
2. Open browser, check console for Firebase initialization
3. Enter passphrase (or if already set, refresh page)
4. Check browser console for auth state changes (should see anonymous sign-in)
5. React DevTools: IdentityContext should show isFirebaseReady: true after a moment
</verification>

<success_criteria>
1. Firebase initializes without errors when app loads
2. Anonymous authentication completes after passphrase is set
3. No hydration mismatches or SSR errors
4. Context provides firebaseUid and isFirebaseReady
5. Auth persists across page refresh (Firebase caches anonymous sessions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence/02-01-SUMMARY.md`
</output>
