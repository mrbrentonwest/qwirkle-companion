---
phase: 02-persistence
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - src/app/page.tsx
  - firestore.rules
autonomous: false
user_setup:
  - service: firebase
    why: "Security rules deployment"
    dashboard_config:
      - task: "Deploy Firestore security rules"
        location: "Firebase Console -> Firestore Database -> Rules -> Paste rules and Publish"

must_haves:
  truths:
    - "User adds a score and refreshes the page - game state is preserved"
    - "User closes browser, reopens app - in-progress game is exactly where they left off"
    - "User can see all player scores, current turn, and round after refresh"
    - "Score changes appear saved within 2 seconds (no manual save needed)"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "Integration with useGamePersistence"
      contains: "useGamePersistence"
    - path: "firestore.rules"
      provides: "Security rules for user data isolation"
      contains: "match /users/{userId}"
  key_links:
    - from: "src/app/page.tsx"
      to: "src/hooks/use-game-persistence.ts"
      via: "useGamePersistence hook"
      pattern: "useGamePersistence"
    - from: "src/app/page.tsx"
      to: "src/contexts/identity-context.tsx"
      via: "useIdentity for userId and isFirebaseReady"
      pattern: "useIdentity.*userId.*isFirebaseReady"
---

<objective>
Integrate game persistence into the main page and verify the complete flow works.

Purpose: Wire up the persistence layer to the existing game UI so that games automatically save and load, fulfilling all PERS requirements.

Output: Updated page.tsx using useGamePersistence, Firestore security rules, and user-verified working persistence.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-persistence/02-RESEARCH.md
@.planning/phases/02-persistence/02-01-SUMMARY.md
@.planning/phases/02-persistence/02-02-SUMMARY.md
@src/app/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Firestore security rules</name>
  <files>firestore.rules</files>
  <action>
Create `firestore.rules` at project root:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users can only access their own data
    // Security relies on:
    // 1. Anonymous Auth (request.auth != null ensures request comes from our app)
    // 2. userId being unguessable SHA-256 hash (can't enumerate other users)
    match /users/{userId}/{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}
```

Note: This rule allows any authenticated user to access any userId path. Security comes from:
1. Anonymous auth ensures only our app can access Firestore
2. userId is SHA-256 hash - unguessable without knowing passphrase
3. No user enumeration possible (no listing of /users collection)

For a production app with sensitive data, you'd want tighter rules, but for a game score tracker this is appropriate.
  </action>
  <verify>
1. File exists: `ls firestore.rules`
2. Contains security rules with `match /users/{userId}`
  </verify>
  <done>
Firestore security rules file created, ready for deployment via Firebase Console.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate useGamePersistence into page.tsx</name>
  <files>src/app/page.tsx</files>
  <action>
Modify `src/app/page.tsx` to use the persistence hook:

1. Import `useGamePersistence` from '@/hooks/use-game-persistence'

2. Get userId and isFirebaseReady from useIdentity:
   ```typescript
   const { isLoading, isIdentified, userId, isFirebaseReady } = useIdentity();
   ```

3. Call useGamePersistence:
   ```typescript
   const { initialGame, isLoading: isPersistenceLoading, saveGame, clearGame } = useGamePersistence({
     userId,
     isFirebaseReady,
   });
   ```

4. Initialize gameState from initialGame:
   - Change initial useState to `useState<GameState | null>(null)`
   - Add useEffect that sets gameState from initialGame when it loads:
     ```typescript
     useEffect(() => {
       if (initialGame && !gameState) {
         setGameState(initialGame);
       }
     }, [initialGame]);
     ```

5. Save on game state changes:
   - Add useEffect that calls saveGame whenever gameState changes:
     ```typescript
     useEffect(() => {
       if (gameState && isFirebaseReady) {
         saveGame(gameState);
       }
     }, [gameState, isFirebaseReady, saveGame]);
     ```

6. Update handleResetGame to also clear from Firestore:
   ```typescript
   const handleResetGame = async () => {
     setGameState(null);
     setGameHistory([]);
     setFutureHistory([]);
     await clearGame();
   };
   ```

7. Show loading state while persistence loads:
   - If `isPersistenceLoading && isFirebaseReady`, show loading indicator or skeleton
   - Don't show GameSetup until we know if there's an existing game

8. Handle the case where user has existing game:
   - If initialGame exists, skip GameSetup and go straight to GameView

DO NOT:
- Save gameHistory/futureHistory to Firestore (too large, not needed)
- Block the entire UI on persistence (identity UI should still work)
- Forget to handle the initialGame -> gameState sync
- Call saveGame before isFirebaseReady is true
  </action>
  <verify>
1. TypeScript compiles: `npm run build`
2. No runtime errors in console
3. useGamePersistence is called with correct options
4. saveGame is called in useEffect when gameState changes
  </verify>
  <done>
page.tsx integrates useGamePersistence, initializes from Firestore data, saves on changes, and clears on reset.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete game persistence flow - games auto-save to Firestore and reload on refresh</what-built>
  <how-to-verify>
**Prerequisites:**
1. Firebase env vars are set in .env.local (copy from .env.local.example)
2. Anonymous Auth is enabled in Firebase Console
3. Firestore database is created in Firebase Console
4. Security rules are deployed (copy firestore.rules content to Firebase Console -> Firestore -> Rules -> Publish)

**Test Flow:**
1. Run `npm run dev` and open http://localhost:3000
2. Enter passphrase if prompted (or use existing)
3. Start a new game with 2 players (e.g., "Alice" and "Bob")
4. Add a score for Alice (e.g., 5 points manual)
5. Add a score for Bob (e.g., 8 points manual)
6. **Hard refresh the page (Cmd+Shift+R or Ctrl+Shift+R)**
7. Verify: Game state is preserved - you should see:
   - Same players (Alice, Bob)
   - Same scores (Alice: 5, Bob: 8)
   - Correct current player turn
   - Correct round number
8. Add another score
9. Close the browser tab completely
10. Reopen http://localhost:3000
11. Verify: Game state still preserved

**Expected Result:**
- All game state persists across refresh and browser close
- No manual save button needed
- Score changes appear in Firestore within ~1 second of action

**Check Firebase Console:**
- Go to Firebase Console -> Firestore Database -> Data
- Navigate to users/{your-userId}/activeGame/current
- Should see your game data with players array, currentPlayerIndex, round, etc.

**Test Reset:**
1. In the game, click "End Game" and confirm
2. Choose "New Game"
3. Refresh the page
4. Verify: You should see GameSetup, not the old game (it was cleared)
  </how-to-verify>
  <resume-signal>Type "approved" if persistence works correctly, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
Before checkpoint:
1. All code compiles without TypeScript errors
2. App runs without console errors
3. Firebase connection established (check Network tab for Firestore requests)

At checkpoint:
1. User verifies full persistence flow works
2. Game survives page refresh
3. Game survives browser close/reopen
4. Reset properly clears Firestore data
</verification>

<success_criteria>
From PERS requirements:
1. PERS-01: Game state auto-saves to Firestore on every score change - verified by seeing immediate Firestore writes
2. PERS-02: Game state includes all players, scores, current turn, round - verified by checking Firestore document structure
3. PERS-03: Game loads from Firestore on app open - verified by refresh test

From phase success criteria:
1. User adds a score and refreshes the page - game state is preserved
2. User closes browser, reopens app - in-progress game is exactly where they left off
3. User can see all player scores, current turn, and round after refresh
4. Score changes appear saved within 2 seconds (no manual save needed)
</success_criteria>

<output>
After completion, create `.planning/phases/02-persistence/02-03-SUMMARY.md`
</output>
