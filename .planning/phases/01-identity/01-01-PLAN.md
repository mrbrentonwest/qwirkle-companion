---
phase: 01-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/use-local-storage.ts
  - src/lib/identity.ts
  - src/lib/types.ts
  - src/contexts/identity-context.tsx
autonomous: true

must_haves:
  truths:
    - "Identity state is accessible from any component via useIdentity hook"
    - "Passphrase hashes deterministically to the same userId"
    - "localStorage reads/writes work without hydration errors"
  artifacts:
    - path: "src/hooks/use-local-storage.ts"
      provides: "SSR-safe localStorage hook"
      exports: ["useLocalStorage"]
    - path: "src/lib/identity.ts"
      provides: "Passphrase hashing utility"
      exports: ["hashPassphrase"]
    - path: "src/lib/types.ts"
      provides: "UserIdentity type"
      contains: "UserIdentity"
    - path: "src/contexts/identity-context.tsx"
      provides: "Identity context and provider"
      exports: ["IdentityProvider", "useIdentity"]
  key_links:
    - from: "src/contexts/identity-context.tsx"
      to: "src/hooks/use-local-storage.ts"
      via: "import useLocalStorage"
      pattern: "useLocalStorage.*userIdentity"
    - from: "src/contexts/identity-context.tsx"
      to: "src/lib/identity.ts"
      via: "import hashPassphrase"
      pattern: "hashPassphrase"
---

<objective>
Create the identity infrastructure: localStorage hook, passphrase hashing, and React Context for identity state management.

Purpose: Establish the foundation for user identification without building UI yet. This layer handles SSR-safety, persistence, and provides the useIdentity hook that UI components will consume.

Output: Working identity context that can store/retrieve passphrase-derived userId from localStorage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-identity/01-RESEARCH.md

@src/lib/types.ts
@src/app/layout.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLocalStorage hook and identity utilities</name>
  <files>
    src/hooks/use-local-storage.ts
    src/lib/identity.ts
    src/lib/types.ts
  </files>
  <action>
Create SSR-safe localStorage hook and identity utilities:

1. Create `src/hooks/use-local-storage.ts`:
   - Implement useLocalStorage<T>(key, initialValue) hook
   - Start with initialValue for SSR (avoid hydration mismatch)
   - Use useEffect to hydrate from localStorage after mount
   - Include isHydrated state for UI loading states
   - Wrap all localStorage operations in try-catch (Safari private mode)
   - Return [value, setValue, removeValue] tuple
   - Use pattern from RESEARCH.md Pattern 1

2. Create `src/lib/identity.ts`:
   - Implement async hashPassphrase(passphrase: string): Promise<string>
   - Use Web Crypto API (crypto.subtle.digest SHA-256)
   - Normalize input: trim whitespace, lowercase
   - Return hex string of hash
   - Add isLocalStorageAvailable() check function
   - Use pattern from RESEARCH.md Pattern 2

3. Update `src/lib/types.ts`:
   - Add UserIdentity interface: { passphrase: string; userId: string }
   - Keep existing types unchanged
  </action>
  <verify>
  - TypeScript compiles: `npx tsc --noEmit`
  - Files exist with correct exports
  </verify>
  <done>
  - useLocalStorage hook handles SSR safely with try-catch
  - hashPassphrase returns deterministic SHA-256 hex string
  - UserIdentity type defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Create IdentityContext and IdentityProvider</name>
  <files>
    src/contexts/identity-context.tsx
  </files>
  <action>
Create React Context for identity state:

1. Create `src/contexts/identity-context.tsx`:
   - Define IdentityContextValue interface:
     - userId: string | null
     - passphrase: string | null
     - isLoading: boolean (true until hydrated from localStorage)
     - isIdentified: boolean (userId !== null)
     - setPassphrase: (passphrase: string) => Promise<void>
     - clearIdentity: () => void

   - Create IdentityContext with undefined default

   - Create useIdentity() hook:
     - Throws error if used outside provider
     - Returns context value

   - Create IdentityProvider component:
     - Use useLocalStorage<UserIdentity | null>('qwirkle-identity', null)
     - Track loading/hydration state
     - setPassphrase: async function that hashes passphrase, stores both passphrase and userId
     - clearIdentity: removes identity from localStorage
     - Memoize context value to prevent unnecessary re-renders

   - Export: IdentityProvider, useIdentity

2. Use 'use client' directive at top (client component)

3. Follow Kent C. Dodds context pattern from RESEARCH.md Pattern 3
  </action>
  <verify>
  - TypeScript compiles: `npx tsc --noEmit`
  - Context exports IdentityProvider and useIdentity
  </verify>
  <done>
  - IdentityProvider manages identity state with localStorage persistence
  - useIdentity hook provides access to identity state
  - setPassphrase hashes and stores passphrase
  - isLoading reflects hydration state
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with no errors
2. All four files exist with documented exports
3. Context can be imported without runtime errors (will be integrated in Plan 02)
</verification>

<success_criteria>
- useLocalStorage hook created with SSR safety
- hashPassphrase utility created with Web Crypto API
- UserIdentity type added to types.ts
- IdentityContext and IdentityProvider created
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-identity/01-01-SUMMARY.md`
</output>
