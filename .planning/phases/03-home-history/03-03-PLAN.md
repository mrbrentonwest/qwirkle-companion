---
phase: 03-home-history
plan: 03
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/app/page.tsx
  - src/components/home/game-detail-dialog.tsx
autonomous: false

must_haves:
  truths:
    - "App opens to home screen (not game setup)"
    - "User can start a new game from home"
    - "User can continue an active game from home"
    - "Completed games appear in history list"
    - "User can view turn-by-turn breakdown of completed game"
    - "Game ending archives to history and returns to home"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "View switching between home and game"
      contains: "HomeScreen"
    - path: "src/components/home/game-detail-dialog.tsx"
      provides: "Dialog to view completed game details"
      min_lines: 40
  key_links:
    - from: "src/app/page.tsx"
      to: "src/components/home/home-screen.tsx"
      via: "HomeScreen import"
      pattern: "HomeScreen"
    - from: "src/app/page.tsx"
      to: "src/lib/firestore-game.ts"
      via: "archiveGame import"
      pattern: "archiveGame"
    - from: "handleEndGame"
      to: "archiveGame"
      via: "function call"
      pattern: "archiveGame\\(userId"
---

<objective>
Integrate home screen into app and complete the game lifecycle with archiving.

Purpose: Wire the home screen components into page.tsx, implement view switching, create the game detail dialog for viewing completed games, and ensure games are archived when they end.

Output: Complete home and history feature with full game lifecycle (start -> play -> end -> archive -> view in history).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-home-history/03-RESEARCH.md
@.planning/phases/03-home-history/03-01-SUMMARY.md
@.planning/phases/03-home-history/03-02-SUMMARY.md

# Files to modify/create
@src/app/page.tsx
@src/components/game/score-history-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game detail dialog for completed games</name>
  <files>src/components/home/game-detail-dialog.tsx</files>
  <action>
Create a dialog component to view completed game details. This reuses the visual pattern from ScoreHistoryDialog but takes a StoredGameState instead of live game data.

```typescript
'use client';

import type { StoredGameState } from '@/lib/types';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from '@/components/ui/dialog';
import { cn } from '@/lib/utils';
import { ScrollArea } from '@/components/ui/scroll-area';
import { X, Trophy, Calendar } from 'lucide-react';
import { QwirkleShape } from '@/components/icons';
import { formatDistanceToNow, format } from 'date-fns';

interface GameDetailDialogProps {
  game: StoredGameState | null;
  isOpen: boolean;
  onOpenChange: (isOpen: boolean) => void;
}

const PLAYER_COLORS = ['#DC2626', '#2563EB', '#16A34A', '#CA8A04', '#9333EA', '#EA580C'];
const PLAYER_SHAPES = ['star', 'circle', 'square', 'clover', 'diamond', 'starburst'];

const depthStyles = {
  raised: "bg-white shadow-[inset_0_1px_0_0_rgba(255,255,255,1.0),0_4px_6px_-1px_rgba(0,0,0,0.1),0_2px_4px_-1px_rgba(0,0,0,0.06)] border border-gray-200",
  recessed: "bg-gray-100 shadow-[inset_0_2px_4px_0_rgba(0,0,0,0.05)] border-b border-white",
};

export function GameDetailDialog({ game, isOpen, onOpenChange }: GameDetailDialogProps) {
  if (!game) return null;

  const roundNumbers = Array.from({ length: game.round }, (_, i) => i + 1);
  const maxScore = Math.max(...game.players.map(p => p.totalScore));

  const dateStr = game.completedAt
    ? format(new Date(game.completedAt), 'MMM d, yyyy')
    : 'Unknown date';
  const relativeTime = game.completedAt
    ? formatDistanceToNow(new Date(game.completedAt), { addSuffix: true })
    : '';

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-md max-h-[90vh] overflow-y-auto rounded-[2.5rem] border-none shadow-2xl p-0 bg-[#F3F4F6] [&>button]:hidden">
        <div className="p-6 space-y-6">
          <DialogHeader className="relative">
            <button
              onClick={() => onOpenChange(false)}
              className="absolute -top-2 -right-2 w-10 h-10 rounded-full bg-white shadow-md flex items-center justify-center text-gray-400 hover:text-gray-900 border border-gray-100 z-10"
            >
              <X className="h-5 w-5" />
            </button>
            <DialogTitle className="font-headline font-black text-3xl flex items-center gap-3 text-orange-600 drop-shadow-sm">
              <div className="w-12 h-12 bg-white rounded-2xl shadow-sm flex items-center justify-center border border-orange-100">
                <Trophy className="text-orange-500 h-7 w-7" />
              </div>
              Game Details
            </DialogTitle>
            <DialogDescription className="flex items-center gap-2 text-gray-400 mt-2">
              <Calendar className="h-4 w-4" />
              <span className="font-medium text-sm">{dateStr}</span>
              <span className="text-xs">({relativeTime})</span>
            </DialogDescription>
          </DialogHeader>

          {/* Players Header with Full Cards */}
          <div className="grid grid-cols-[40px_1fr] gap-3 px-1">
            <div />
            <div className="grid gap-2" style={{ gridTemplateColumns: `repeat(${game.players.length}, 1fr)` }}>
              {game.players.map((player, idx) => {
                const playerColor = PLAYER_COLORS[idx % PLAYER_COLORS.length];
                const playerShape = PLAYER_SHAPES[idx % PLAYER_SHAPES.length];
                const isLeader = player.totalScore === maxScore && maxScore > 0;

                return (
                  <div
                    key={player.id}
                    className={cn(
                      'relative p-2 rounded-[1.5rem] flex flex-col justify-between h-28 overflow-hidden border transition-all',
                      'bg-white border-gray-100 shadow-sm'
                    )}
                  >
                    <QwirkleShape
                      shape={playerShape}
                      className="absolute -right-2 -bottom-2 w-16 h-16 opacity-[0.10]"
                      style={{ color: playerColor }}
                    />

                    <div className="flex justify-between items-start relative z-10">
                      <div
                        className="w-8 h-8 rounded-full flex items-center justify-center shadow-sm"
                        style={{ backgroundColor: playerColor }}
                      >
                        <QwirkleShape shape={playerShape} className="w-4 h-4 text-white" />
                      </div>
                      {isLeader && (
                        <div className="bg-yellow-100 p-1 rounded-full">
                          <Trophy className="h-3 w-3 text-yellow-600" />
                        </div>
                      )}
                    </div>

                    <div className="relative z-10 mt-1">
                      <p className="font-headline font-bold text-xs text-gray-700 truncate mb-0.5">
                        {player.name}
                      </p>
                      <p
                        className="text-3xl font-black font-headline tracking-tighter leading-none"
                        style={{ color: playerColor }}
                      >
                        {player.totalScore}
                      </p>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>

          <ScrollArea className="h-[50vh] px-1">
            <div className="space-y-3 pb-4">
              {roundNumbers.map((round) => (
                <div key={round} className="grid grid-cols-[40px_1fr] gap-3 items-center">
                  <div className="text-center font-black text-gray-400 text-xs tracking-tighter">
                    R{round}
                  </div>
                  <div className="grid gap-2" style={{ gridTemplateColumns: `repeat(${game.players.length}, 1fr)` }}>
                    {game.players.map((player) => {
                      const turn = player.scores.find(s => s.turnNumber === round);
                      const score = turn?.score;
                      const isQwirkle = turn?.isQwirkle ?? false;
                      const isBonus = turn?.type === 'bonus';

                      return (
                        <div
                          key={`${player.id}-${round}`}
                          className={cn(
                            "h-12 rounded-2xl flex items-center justify-center font-black text-lg transition-all",
                            score !== undefined ? depthStyles.raised : "bg-gray-100/50 border border-dashed border-gray-200 opacity-40",
                            isQwirkle && "ring-2 ring-orange-400 ring-offset-1 bg-orange-50",
                            isBonus && "ring-2 ring-yellow-400 bg-yellow-50"
                          )}
                          style={{ color: score !== undefined ? PLAYER_COLORS[game.players.indexOf(player) % PLAYER_COLORS.length] : 'transparent' }}
                        >
                          {score !== undefined ? score : ''}
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>
          </ScrollArea>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```
  </action>
  <verify>Run `npm run typecheck` - dialog should compile without errors.</verify>
  <done>GameDetailDialog created with turn-by-turn breakdown and date display, matching ScoreHistoryDialog visual style.</done>
</task>

<task type="auto">
  <name>Task 2: Wire home screen and game archiving into page.tsx</name>
  <files>src/app/page.tsx</files>
  <action>
Refactor page.tsx to add view switching between home and game, integrate game history, and archive games when they end.

**Key changes:**

1. Add new imports at the top:
```typescript
import { HomeScreen } from '@/components/home/home-screen';
import { GameDetailDialog } from '@/components/home/game-detail-dialog';
import { useGameHistory } from '@/hooks/use-game-history';
import { archiveGame } from '@/lib/firestore-game';
import type { StoredGameState } from '@/lib/types';
```

2. Add view state and selected game state after existing state declarations:
```typescript
const [view, setView] = useState<'home' | 'game'>('home');
const [selectedGame, setSelectedGame] = useState<StoredGameState | null>(null);
```

3. Add useGameHistory hook call:
```typescript
const { games: historyGames, isLoading: isHistoryLoading, error: historyError, refetch: refetchHistory } = useGameHistory(userId, isFirebaseReady);
```

4. Update the useEffect that initializes from Firestore to NOT auto-switch to game view:
```typescript
// Initialize gameState from Firestore when loaded
useEffect(() => {
  if (initialGame && !gameState) {
    setGameState(initialGame);
    // Don't auto-switch to game - user decides from home
  }
}, [initialGame, gameState]);
```

5. Add handlers for home screen actions:
```typescript
const handleGoToHome = useCallback(() => {
  setView('home');
  refetchHistory();
}, [refetchHistory]);

const handleContinueGame = useCallback(() => {
  setView('game');
}, []);

const handleNewGame = useCallback(() => {
  setGameState(null);
  setGameHistory([]);
  setFutureHistory([]);
  setView('game'); // Go to game setup
}, []);

const handleSelectHistoryGame = useCallback((game: StoredGameState) => {
  setSelectedGame(game);
}, []);
```

6. Update handleEndGame to archive and return to home:
```typescript
const handleEndGame = async (bonusPlayerId: string | null) => {
  if (!gameState || !userId) return;

  // Build final state
  let finalPlayers = [...gameState.players];
  if (bonusPlayerId) {
    finalPlayers = finalPlayers.map(p => {
      if (p.id === bonusPlayerId) {
        const bonusScore: TurnScore = { turnNumber: gameState.round, score: 6, isQwirkle: false, type: 'bonus' };
        return {
          ...p,
          scores: [...p.scores, bonusScore],
          totalScore: p.totalScore + 6,
        };
      }
      return p;
    });
  }

  const finalState: GameState = {
    ...gameState,
    players: finalPlayers,
    isGameActive: false,
    isGameOver: true,
  };

  // Archive to history first
  try {
    await archiveGame(userId, finalState);
  } catch (err) {
    console.error('Failed to archive game:', err);
  }

  // Clear active game
  await clearGame();

  // Update local state
  setGameState(null);
  setGameHistory([]);
  setFutureHistory([]);

  // Return to home
  handleGoToHome();
};
```

7. Update the main render logic to show home or game based on view state:

Replace the existing main section with conditional rendering:
```tsx
<main className="flex-1 flex flex-col">
  {/* Show loading state while persistence is loading */}
  {isPersistenceLoading && isFirebaseReady ? (
    <div className="flex-1 flex items-center justify-center">
      <div className="text-center">
        <QwirkleShape shape="starburst" className="h-12 w-12 text-orange-500 mx-auto animate-spin" />
        <p className="mt-4 text-gray-500 text-sm">Loading your game...</p>
      </div>
    </div>
  ) : view === 'home' ? (
    <HomeScreen
      hasActiveGame={!!gameState}
      onNewGame={handleNewGame}
      onContinueGame={handleContinueGame}
      games={historyGames}
      isLoadingHistory={isHistoryLoading}
      historyError={historyError}
      onSelectGame={handleSelectHistoryGame}
    />
  ) : !gameState ? (
    <GameSetup onStartGame={handleStartGame} />
  ) : (
    <GameView
      gameState={gameState}
      onAddScore={handleAddScore}
      onEndGame={handleEndGame}
      onResetGame={handleResetGame}
      isHistoryOpen={isHistoryOpen}
      onHistoryOpenChange={setHistoryOpen}
      onUndo={handleUndo}
      onRedo={handleRedo}
      canUndo={gameHistory.length > 0}
      canRedo={futureHistory.length > 0}
    />
  )}
</main>
```

8. Add GameDetailDialog before the closing div:
```tsx
{/* Game Detail Dialog for viewing completed games */}
<GameDetailDialog
  game={selectedGame}
  isOpen={!!selectedGame}
  onOpenChange={(open) => !open && setSelectedGame(null)}
/>
```

9. Add a home button to the header when in game view. Update the header section to include a home button:

In the header div that contains the logo, add a back button when in game view:
```tsx
<div className="flex items-center gap-2">
  {view === 'game' && (
    <button
      onClick={handleGoToHome}
      className="w-10 h-10 rounded-xl bg-gray-100 hover:bg-gray-200 flex items-center justify-center text-gray-500 transition-colors"
    >
      <svg className="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
      </svg>
    </button>
  )}
  <QwirkleShape shape="starburst" className="h-8 w-8 text-orange-500 drop-shadow-sm" />
  ...
</div>
```

Also add TurnScore to the type import at the top if not already there.

**Important:** Make handleEndGame async and ensure the archiveGame call happens BEFORE clearGame.
  </action>
  <verify>Run `npm run typecheck` - should compile. Run `npm run dev` and verify app loads to home screen.</verify>
  <done>page.tsx refactored with view switching, game history integration, and game archiving on end.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete home and history feature with game lifecycle</what-built>
  <how-to-verify>
1. Open the app (npm run dev, then http://localhost:9002)
2. Verify you see the HOME SCREEN (not game setup) with:
   - "START NEW GAME" button (or "CONTINUE GAME" if you have an active game)
   - "Recent Games" section (may be empty)
3. Click "Start New Game" - should go to player setup
4. Enter 2 player names, start game
5. Add a few scores for each player
6. Notice the HOME button in top-left of header - click it
7. Verify you return to home screen with "CONTINUE GAME" button visible
8. Click "Continue Game" - should return to your in-progress game
9. Add more scores, then end the game (tap "End Game" in footer)
10. Verify you return to home screen
11. Verify the completed game appears in "Recent Games" list
12. Tap the completed game card
13. Verify the Game Details dialog shows turn-by-turn breakdown with scores
14. Close dialog, start another new game - complete it
15. Verify both games now appear in history (most recent first)
  </how-to-verify>
  <resume-signal>Type "approved" if all verifications pass, or describe any issues encountered.</resume-signal>
</task>

</tasks>

<verification>
- `npm run typecheck` passes
- `npm run dev` starts without errors
- App opens to home screen (not game setup)
- New game flow works: home -> setup -> game -> end -> home
- Continue game flow works: home -> game (in progress) -> home -> continue
- Game history displays completed games with players and scores
- Game detail dialog shows turn-by-turn breakdown
- Games are archived to Firestore on end (check Firebase console)
</verification>

<success_criteria>
- HOME-01: Home screen displays before game setup (VERIFIED)
- HOME-02: "New Game" button to start fresh game (VERIFIED)
- HOME-03: "Continue Game" shown when unfinished game exists (VERIFIED)
- HIST-01: Home screen shows list of past games (VERIFIED)
- HIST-02: Each game shows players, final scores, and winner (VERIFIED)
- HIST-03: User can tap a completed game to see turn-by-turn breakdown (VERIFIED)
- HIST-04: In-progress game shows "Continue" option prominently (VERIFIED)
</success_criteria>

<output>
After completion, create `.planning/phases/03-home-history/03-03-SUMMARY.md`
</output>
